---
title: "Shiny Dashboard Structure"
output:
  html_document:
    toc: true
    template: ./template-toc.html
---

```{r echo = FALSE, message=FALSE}
library(shiny)
library(shinydashboard)
library(webshot)

knitr::opts_chunk$set(collapse = TRUE, comment = "##")

# Print HTML tags as HTML text
knit_print.shiny.tag <- function(x, ...) {
  as.character(x)
}
```


# Background: Shiny and HTML

To understand how the parts of a dashboard work together, we first need to know how a Shiny UI is built, and how it relates to the HTML of a web page.

The HTML tag functions in Shiny, like `div()` and `p()` return objects that can be rendered as HTML. For example, when you run these commands at the R console, it will print out HTML:

```{r}
# A basic div
div(class = "my-class", "Div content")

# Nested HTML tags
div(class = "my-class", p("Paragraph text"))
```

Some functions return more complex HTML fragments, and they insulate you, the user, from having to know all the ins and outs of the HTML required to create things like a text input or a sidebar:

```{r}
textInput("Id", "Label")

sidebarPanel(
  div("First div"),
  div("Second div")
)
```

The UI for a Shiny app is built out of these pieces of HTML. The **shinydashboard** package provides a set of functions designed to create HTML that will generate a dashboard. If you copy the UI code for a dashboard page (above) and paste into the R console, it will print out HTML for the dashboard.


# Structure overview

The `dashboardPage()` function expects three components: a header, sidebar, and body:

```{r eval=FALSE}
dashboardPage(
  dashboardHeader(),
  dashboardSidebar(),
  dashboardBody()
)
```

For more complicated apps, splitting app into pieces can make it more readable:

```{r eval=FALSE}
header <- dashboardHeader()

sidebar <- dashboardSidebar()

body <- dashboardBody()

dashboardPage(header, sidebar, body)
```

Now we'll look at each of the three main components of a **shinydashboard**.

# Header

A header can have a title and dropdown menus. Here's an example:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/menus/', 'images/header.png',
  delay=1, vwidth=780, selector="header") %>%
  resize('75%') %>%
  shrink()
```

![Header](images/header.png)

Setting the title is simple; just use the `title` argument:

```{r eval=FALSE}
dashboardHeader(title = "My Dashboard")
```

The dropdown menus are generated by the `dropdownMenu()` function. There are three types of menus -- messages, notifications, and tasks -- and each one must be populated with a corresponding type of item.

## Message menus

A message menu looks like this:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/menus/', 'images/menu-messages.png',
  delay=0.5, vwidth=992,
  selector = c("header", ".messages-menu .dropdown-menu"),
  eval = "casper.then(function() {
    this.click('.messages-menu a.dropdown-toggle');
    this.wait(500);
  });"
) %>%
  resize('65%') %>%
  shrink()
```

![Messages menu](images/menu-messages.png)


A `messageItem` contained in a message menu needs values for `from` and `message`. You can also control the icon and a notification time string. By default, the icon is a silhouette of a person. ([Read more about icons](appearance.html#icons)) The time string can be any text. For example, it could be a relative date/time like `"5 minutes"`, `"today"`, or `"12:30pm yesterday"`, or an absolute time, like `"2014-12-01 13:45"`.

```{r eval=FALSE}
dropdownMenu(type = "messages",
  messageItem(
    from = "Sales Dept",
    message = "Sales are steady this month."
  ),
  messageItem(
    from = "New User",
    message = "How do I register?",
    icon = icon("question"),
    time = "13:45"
  ),
  messageItem(
    from = "Support",
    message = "The new server is ready.",
    icon = icon("life-ring"),
    time = "2014-12-01"
  )
)
```


### Dynamic content

In most cases, you'll want to make the content dynamic. That means that the HTML content is generated on the server side and sent to the client for rendering. In the UI code, you'd use `dropdownMenuOutput` like this:

```{r eval=FALSE}
  dashboardHeader(dropdownMenuOutput("messageMenu"))
```

And on the server side, you'd generate the entire menu in a `renderMenu`, like this:

```{r eval=FALSE}
output$messageMenu <- renderMenu({
  # Code to generate each of the messageItems here, in a list. This assumes
  # that messageData is a data frame with two columns, 'from' and 'message'.
  msgs <- apply(messageData, 1, function(row) {
    messageItem(from = row[["from"]], message = row[["message"]])
  })

  # This is equivalent to calling:
  #   dropdownMenu(type="messages", msgs[[1]], msgs[[2]], ...)
  dropdownMenu(type = "messages", .list = msgs)
})
```

For an interactive example, see the help page for `?renderMenu`.

This is a customized version of dynamic UI in Shiny. For more about using dynamic UI, see [this example](http://shiny.rstudio.com/gallery/dynamic-ui.html).

## Notification menus

This is what a notification menu looks like:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/menus/', 'images/menu-notifications.png',
  delay=0.5, vwidth=992,
  selector = c("header", ".notifications-menu .dropdown-menu"),
  eval = "casper.then(function() {
    this.click('.notifications-menu a.dropdown-toggle');
    this.wait(500);
  });"
) %>%
  resize('65%') %>%
  shrink()
```

![Notifications menu](images/menu-notifications.png)

A `notificationItem` contained in a notification contains a text notification. You can also control the icon and the status color. The different possible statuses are shown [here](appearance.html#statuses-and-colors).

```{r eval=FALSE}
dropdownMenu(type = "notifications",
  notificationItem(
    text = "5 new users today",
    icon("users")
  ),
  notificationItem(
    text = "12 items delivered",
    icon("truck"),
    status = "success"
  ),
  notificationItem(
    text = "Server load at 86%",
    icon = icon("exclamation-triangle"),
    status = "warning"
  )
)
```


## Task menus

This is a task menu:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/menus/', 'images/menu-tasks.png',
  delay=0.5, vwidth=992,
  selector = c("header", ".tasks-menu .dropdown-menu"),
  eval = "casper.then(function() {
    this.click('.tasks-menu a.dropdown-toggle');
    this.wait(500);
  });"
) %>%
  resize('65%') %>%
  shrink()
```

![Tasks menu](images/menu-tasks.png)

Task items have a progress bar and a text label. You can also specify the color of the bar. Valid colors are listed in `?validColors`.

```{r eval=FALSE}
dropdownMenu(type = "tasks", badgeStatus = "success",
  taskItem(value = 90, color = "green",
    "Documentation"
  ),
  taskItem(value = 17, color = "aqua",
    "Project X"
  ),
  taskItem(value = 75, color = "yellow",
    "Server deployment"
  ),
  taskItem(value = 80, color = "red",
    "Overall project"
  )
)
```

## Disabling the header

If you don't want to show a header bar, you can disable it with:

```{r eval=FALSE}
dashboardHeader(disable = TRUE)
```


# Sidebar

A sidebar is typically used for quick navigation. It can contain menu items that behave like tabs in a `tabPanel`, as well as Shiny inputs, like sliders and text inputs.

```{r eval=FALSE, echo=FALSE}
appshot('_apps/sidebar/', 'images/sidebar.png',
  delay=0.5, vwidth=1000,
  selector = c(".main-header > .logo", ".sidebar"),
  expand = c(0, 10, 10, 0),
  eval = "casper.then(function() {
    this.click('ul.sidebar-menu > li.treeview > a');
    this.wait(500);
  });"
) %>%
  resize('75%') %>%
  shrink()
```

![Sidebar](images/sidebar.png)


## Sidebar menu items and tabs

Links in the sidebar can be used like `tabPanel`s from Shiny. That is, when you click on a link, it will display different content in the body of the dashboard. Here is an example of a simple tabPanel:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/sidebar-tabs/', 'images/sidebar-tabs.png',
  delay=1, vwidth=1000,
  cliprect = c(0, 0, 800, 300)
) %>%
  resize('75%') %>%
  shrink()
```

![Tabs](images/sidebar-tabs.png)

When the user clicks on one of the menu items, it switches content in the main body:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/sidebar-tabs/', 'images/sidebar-tabs-2.png',
  delay=0.5, vwidth=1000,
  cliprect = c(0, 0, 800, 300),
  eval = "casper.then(function() {
    this.click('ul.sidebar-menu > li > a[href=\"#shiny-tab-widgets\"]');
    this.wait(500);
  });"
) %>%
  resize('75%') %>%
  shrink()
```

![Tabs](images/sidebar-tabs-2.png)


The menu items are put in `sidebarMenu()` as follows. To match up a `menuItem` with a `tabItem`, make sure that they have matching values for `tabName`. 

```{r eval=FALSE}
## ui.R ##
sidebar <- dashboardSidebar(
  sidebarMenu(
    menuItem("Dashboard", tabName = "dashboard", icon = icon("dashboard")),
    menuItem("Widgets", icon = icon("th"), tabName = "widgets",
             badgeLabel = "new", badgeColor = "green")
  )
)

body <- dashboardBody(
  tabItems(
    tabItem(tabName = "dashboard",
      h2("Dashboard tab content")
    ),

    tabItem(tabName = "widgets",
      h2("Widgets tab content")
    )
  )
)

# Put them together into a dashboardPage
dashboardPage(
  dashboardHeader(title = "Simple tabs"),
  sidebar,
  body
)
```

`menuItem`s have an option icon, which is created by the `icon()` function from Shiny. ([More information](appearance.html#icons) about using icons.) They also have an optional badge, with `badgeLabel` and `badgeColor`.

A `menuItem` can do other things besides control tabs; it can also contain a link to external content, if you supply a value for `href`. By default, these external links open in a new browser tab or window; this can be controlled with the `newtab` option.

```{r eval=FALSE}
  menuItem("Source code", icon = icon("file-code-o"), 
           href = "https://github.com/rstudio/shinydashboard/")
```

### Bookmarking and restoring selected tabs

As of version 0.14, Shiny has the ability to [bookmark and restore](http://shiny.rstudio.com/articles/bookmarking-state.html) the state of an application. To be able to bookmark and restore the selected `tabItem` in an app built with shinydashboard, you must call `sidebarMenu()` with an `id`. For example:

```{r eval=FALSE}
sidebarMenu(id = "sidebar",
  ....
)
```

If you've used bookmarking in a Shiny app before, you know that the UI must be wrapped in a function. The `sidebarMenu()` must be called inside the UI function. It does not work to call it outside the UI function, saved the result in a variable, and then use that result in the UI function -- if you do this, then the selected tab will save, but it will not restore.

### Dynamic content

A sidebar menu can be generated dynamically, with `renderMenu` and `sidebarMenuOutput`. Here is an example app with a sidebar that is generated on the server side.


```{r eval=FALSE}
ui <- dashboardPage(
  dashboardHeader(title = "Dynamic sidebar"),
  dashboardSidebar(
    sidebarMenuOutput("menu")
  ),
  dashboardBody()
)

server <- function(input, output) {
  output$menu <- renderMenu({
    sidebarMenu(
      menuItem("Menu item", icon = icon("calendar"))
    )
  })
}

shinyApp(ui, server)
```


It's also possible to dynamically generate individual items:

```{r eval=FALSE}
ui <- dashboardPage(
  dashboardHeader(title = "Dynamic sidebar"),
  dashboardSidebar(
    sidebarMenu(
      menuItemOutput("menuitem")
    )
  ),
  dashboardBody()
)

server <- function(input, output) {
  output$menuitem <- renderMenu({
    menuItem("Menu item", icon = icon("calendar"))
  })
}

shinyApp(ui, server)
```


## Inputs in the sidebar

A sidebar can also contain ordinary inputs, like `sliderInput`s and `textInput`s.

```{r eval=FALSE, echo=FALSE}
appshot('_apps/sidebar-inputs/', 'images/sidebar-inputs.png',
  delay=1, vwidth=1000,
  selector = c(".main-header > .logo", ".sidebar"),
  expand = c(0, 10, 10, 0)
) %>%
  resize('75%') %>%
  shrink()
```

![Sidebar inputs](images/sidebar-inputs.png)

**shinydashboard** also includes a special type of input, a `sidebarSearchForm`, which is on top in the screenshot above. This is essentially a specially formatted text input and and actionButton which appears as a magnifying glass icon (the icon can be changed with the `icon` argument).

```{r eval=FALSE}
  sidebarSearchForm(textId = "searchText", buttonId = "searchButton",
                    label = "Search...")
```

For this search form, the corresponding values in the server-side code would be `input$searchText` and `input$searchButton`.


## Disabling the sidebar

If you don't want a sidebar, you can disable it with:

```{r eval=FALSE}
dashboardSidebar(disable = TRUE)
```


# Body

The body of a dashboard page can contain any regular Shiny content. However, if you're creating a dashboard you'll likely want to make something that's more structured. The basic building block of most dashboards is a `box`. Boxes in turn can contain any content.


## Boxes

Boxes are the main building blocks of dashboard pages. A basic box can be created with the `box()` function, and the contents of the box can be (most) any Shiny UI content.

In a typical dashboard, these boxes would be placed inside a `fluidRow()` (we'll see more on dashboard layout later):

```{r eval=FALSE}
# This is just the body component of a dashboard
dashboardBody(
  fluidRow(
    box(plotOutput("plot1")),
    
    box(
      "Box content here", br(), "More box content",
      sliderInput("slider", "Slider input:", 1, 100, 50),
      textInput("text", "Text input:")
    )
  )
)
```

```{r eval=FALSE, echo=FALSE}
appshot('_apps/body-boxes/', 'images/body-boxes-basic.png',
  delay=1, selector = 'div.row', expand = c(10,0,0,0)) %>%
  resize("75%") %>%
  shrink()
```

![Basic boxes](images/body-boxes-basic.png)

Boxes can have titles and header bar colors with the `title` and `status` options. The different possible statuses are shown [here](appearance.html#statuses-and-colors).

```{r eval=FALSE}
box(title = "Histogram", status = "primary", plotOutput("plot2", height = 250)),

box(
  title = "Inputs", status = "warning",
  "Box content here", br(), "More box content",
  sliderInput("slider", "Slider input:", 1, 100, 50),
  textInput("text", "Text input:")
)
```

```{r eval=FALSE, echo=FALSE}
appshot('_apps/body-boxes/', 'images/body-boxes-header.png',
  delay=1, selector = 'div.row:nth-of-type(2)', expand = c(10,0,0,0)) %>%
  resize("75%") %>%
  shrink()
```

![Box header color and title](images/body-boxes-header.png)


You can have solid headers with `solidHeader=TRUE`, and display a button in the upper right that will collapse the box with `collapsible=TRUE`:

```{r eval=FALSE}
box(
  title = "Histogram", status = "primary", solidHeader = TRUE,
  collapsible = TRUE,
  plotOutput("plot3", height = 250)
),

box(
  title = "Inputs", status = "warning", solidHeader = TRUE,
  "Box content here", br(), "More box content",
  sliderInput("slider", "Slider input:", 1, 100, 50),
  textInput("text", "Text input:")
)
```

```{r eval=FALSE, echo=FALSE}
appshot('_apps/body-boxes/', 'images/body-boxes-header-2.png',
  delay=1, selector = 'div.row:nth-of-type(3)', expand = c(10,0,0,0)) %>%
  resize("75%") %>%
  shrink()
```

![Solid header and collapse](images/body-boxes-header-2.png)

If you want the boxes to not have a gray or colored bar on top, use `solidHeader=TRUE` and don't give a value for `status`:

```{r eval=FALSE}
box(
  title = "Histogram", solidHeader = TRUE,
  collapsible = TRUE,
  plotOutput("plot3", height = 250)
),

box(
  title = "Inputs", solidHeader = TRUE,
  "Box content here", br(), "More box content",
  sliderInput("slider", "Slider input:", 1, 100, 50),
  textInput("text", "Text input:")
)
```

```{r eval=FALSE, echo=FALSE}
appshot('_apps/body-boxes/', 'images/body-boxes-header-3.png',
  delay=1, selector = 'div.row:nth-of-type(4)', expand = c(10,0,0,0)) %>%
  resize("75%") %>%
  shrink()
```

![No colored bar](images/body-boxes-header-3.png)


Finally, it's also possible to have a solid background, with the `background` option. The different possible colors are shown [here](appearance.html#statuses-and-colors).


```{r eval=FALSE}
box(
  title = "Histogram", background = "maroon", solidHeader = TRUE,
  plotOutput("plot4", height = 250)
),

box(
  title = "Inputs", background = "black",
  "Box content here", br(), "More box content",
  sliderInput("slider", "Slider input:", 1, 100, 50),
  textInput("text", "Text input:")
)
```

```{r eval=FALSE, echo=FALSE}
appshot('_apps/body-boxes/', 'images/body-boxes-header-4.png',
  delay=1, selector = 'div.row:nth-of-type(5)', expand = c(10,0,0,0)) %>%
  resize("75%") %>%
  shrink()
```

![Solid background](images/body-boxes-header-4.png)


### tabBox

If you want a box to have tabs for displaying different sets of content, you can use a `tabBox`.

```{r eval=FALSE, echo=FALSE}
appshot('_apps/body-tabboxes/', 'images/body-tabboxes.png',
  delay=1, selector = 'section.content', expand = c(10,0,0,0)) %>%
  resize("75%") %>%
  shrink()
```

![Tabbed boxes](images/body-tabboxes.png)


The code to generate this app is below. A `tabBox` is similar to a `tabsetPanel` from Shiny in that it takes `tabPanels` as inputs, allows you to choose which tab is selected, and can be assigned an `id`. If `id` is present, you can access which tab is selected from the server; in the example below, it's accessed with `input$tabset1`.

A `tabBox` also has similarities to a regular `box` from shinydashboard, in that you can control the `height`, `width`, and `title`. You can also choose which side the tabs appear on, with the `side` argument. Note that if `side="right"`, the tabs will be displayed in reverse order.


```{r eval=FALSE}
body <- dashboardBody(
  fluidRow(
    tabBox(
      title = "First tabBox",
      # The id lets us use input$tabset1 on the server to find the current tab
      id = "tabset1", height = "250px",
      tabPanel("Tab1", "First tab content"),
      tabPanel("Tab2", "Tab content 2")
    ),
    tabBox(
      side = "right", height = "250px",
      selected = "Tab3",
      tabPanel("Tab1", "Tab content 1"),
      tabPanel("Tab2", "Tab content 2"),
      tabPanel("Tab3", "Note that when side=right, the tab order is reversed.")
    )
  ),
  fluidRow(
    tabBox(
      # Title can include an icon
      title = tagList(shiny::icon("gear"), "tabBox status"),
      tabPanel("Tab1",
        "Currently selected tab from first box:",
        verbatimTextOutput("tabset1Selected")
      ),
      tabPanel("Tab2", "Tab content 2")
    )
  )
)

shinyApp(
  ui = dashboardPage(
    dashboardHeader(title = "tabBoxes"),
    dashboardSidebar(),
    body
  ),
  server = function(input, output) {
    # The currently selected tab from the first box
    output$tabset1Selected <- renderText({
      input$tabset1
    })
  }
)
```


### infoBox

There is a special kind of box that is used for displaying simple numeric or text values, with an icon. Here are some examples:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/body-infoboxes/', 'images/body-infoboxes.png',
    delay=1, selector = c('div.row', 'div.row:nth-child(2)'),
    expand = c(10,0,0,0)) %>%
  resize("75%") %>%
  shrink()
```

![Info boxes](images/body-infoboxes.png)

The code to generate these `infoBox`es is below. The first row of infoBoxes uses the default setting of `fill=FALSE`, while the second row uses `fill=TRUE`.

Since the content of an `infoBox` will usually be dynamic, **shinydashboard** contains the helper functions `infoBoxOutput` and `renderInfoBox` for dynamic content. The different possible colors are shown [here](appearance.html#statuses-and-colors).


```{r eval=FALSE}
library(shinydashboard)

ui <- dashboardPage(
  dashboardHeader(title = "Info boxes"),
  dashboardSidebar(),
  dashboardBody(
    # infoBoxes with fill=FALSE
    fluidRow(
      # A static infoBox
      infoBox("New Orders", 10 * 2, icon = icon("credit-card")),
      # Dynamic infoBoxes
      infoBoxOutput("progressBox"),
      infoBoxOutput("approvalBox")
    ),

    # infoBoxes with fill=TRUE
    fluidRow(
      infoBox("New Orders", 10 * 2, icon = icon("credit-card"), fill = TRUE),
      infoBoxOutput("progressBox2"),
      infoBoxOutput("approvalBox2")
    ),

    fluidRow(
      # Clicking this will increment the progress amount
      box(width = 4, actionButton("count", "Increment progress"))
    )
  )
)

server <- function(input, output) {
  output$progressBox <- renderInfoBox({
    infoBox(
      "Progress", paste0(25 + input$count, "%"), icon = icon("list"),
      color = "purple"
    )
  })
  output$approvalBox <- renderInfoBox({
    infoBox(
      "Approval", "80%", icon = icon("thumbs-up", lib = "glyphicon"),
      color = "yellow"
    )
  })

  # Same as above, but with fill=TRUE
  output$progressBox2 <- renderInfoBox({
    infoBox(
      "Progress", paste0(25 + input$count, "%"), icon = icon("list"),
      color = "purple", fill = TRUE
    )
  })
  output$approvalBox2 <- renderInfoBox({
    infoBox(
      "Approval", "80%", icon = icon("thumbs-up", lib = "glyphicon"),
      color = "yellow", fill = TRUE
    )
  })
}

shinyApp(ui, server)
```


### valueBox

`valueBox`es are similar to `infoBox`es, but have a somewhat different appearance.

```{r eval=FALSE, echo=FALSE}
appshot('_apps/body-valueboxes/', 'images/body-valueboxes.png',
  delay=1, selector = 'div.row', expand = c(10,0,0,0)) %>%
  resize("75%") %>%
  shrink()
```

![Value boxes](images/body-valueboxes.png)

The code to generate these `valueBox`es is below. As with the `infoBox`es above, some of these `valueBox`es are static and some are dynamic.

```{r eval=FALSE}
library(shinydashboard)

ui <- dashboardPage(
  dashboardHeader(title = "Value boxes"),
  dashboardSidebar(),
  dashboardBody(
    fluidRow(
      # A static valueBox
      valueBox(10 * 2, "New Orders", icon = icon("credit-card")),

      # Dynamic valueBoxes
      valueBoxOutput("progressBox"),

      valueBoxOutput("approvalBox")
    ),
    fluidRow(
      # Clicking this will increment the progress amount
      box(width = 4, actionButton("count", "Increment progress"))
    )
  )
)

server <- function(input, output) {
  output$progressBox <- renderValueBox({
    valueBox(
      paste0(25 + input$count, "%"), "Progress", icon = icon("list"),
      color = "purple"
    )
  })

  output$approvalBox <- renderValueBox({
    valueBox(
      "80%", "Approval", icon = icon("thumbs-up", lib = "glyphicon"),
      color = "yellow"
    )
  })
}

shinyApp(ui, server)
```


## Layouts

Laying out the boxes requires a little knowledge of the Bootstrap grid layout system. The body can be treated as a region divided in to 12 columns of equal width, and any number of rows, of variable height. When you place a box (or other item) in the grid, you can specify how many of the 12 columns you want it to occupy. In this screenshot, the first row of boxes each are 4 columns wide, and the second column of boxes are each 6 columns wide.

Broadly speaking, there are two ways of laying out boxes: with a row-based layout, or with a column-based layout.

### Row-based layout

In a row-based layout, boxes must go in a row created by `fluidRow()`. Rows have a grid width of 12, so a box with `width=4` takes up one-third of the width, and a box with `width=6` (the default) takes up half of the width.

With a row-based layout, the tops of the boxes in each row will be aligned, but the bottoms may not be -- it depends on the content of each box. A row-based layout might look like this:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/layout-rows/', 'images/layout-rows.png',
  delay=1, vwidth=1000, selector = 'section.content') %>%
  resize("50%") %>%
  shrink()
```

![Row-based layout](images/layout-rows.png)

This code is the basic scaffolding for these three rows of boxes:

```{r eval=FALSE}
body <- dashboardBody(
  fluidRow(
    box(title = "Box title", "Box content"),
    box(status = "warning", "Box content")
  ),

  fluidRow(
    box(
      title = "Title 1", width = 4, solidHeader = TRUE, status = "primary",
      "Box content"
    ),
    box(
      title = "Title 2", width = 4, solidHeader = TRUE,
      "Box content"
    ),
    box(
      title = "Title 1", width = 4, solidHeader = TRUE, status = "warning",
      "Box content"
    )
  ),

  fluidRow(
    box(
      width = 4, background = "black",
      "A box with a solid black background"
    ),
    box(
      title = "Title 5", width = 4, background = "light-blue",
      "A box with a solid light-blue background"
    ),
    box(
      title = "Title 6",width = 4, background = "maroon",
      "A box with a solid maroon background"
    )
  )
)

# We'll save it in a variable `ui` so that we can preview it in the console
ui <- dashboardPage(
  dashboardHeader(title = "Row layout"),
  dashboardSidebar(),
  body
)

# Preview the UI in the console
shinyApp(ui = ui, server = function(input, output) { })
```


It's possible to force the boxes to all be the same height, by setting `height`. In contrast to `width`, which is set using the 12-wide Bootstrap gride, `height` is specified in pixels. (This difference is because HTML/CSS layout handles width and height differently. Unfortunately, there isn't a straightforward way to get equal column heights with Bootstrap.)

For example:

```{r eval=FALSE}
box(title = "Box title", height = 300, "Box content"),
```

If we set the height of all the boxes, we can get a dashboard like this:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/layout-rows/', 'images/layout-rows-height.png',
  delay=1, vwidth=1000, selector = 'section.content',
  envvars = c(USE_BOX_HEIGHT='TRUE')) %>%
  resize("50%") %>%
  shrink()
```

![Row-based layout with fixed height](images/layout-rows-height.png)

### Column-based layout

With a column-based layout, you first create a column and then place boxes within those columns.

```{r eval=FALSE, echo=FALSE}
appshot('_apps/layout-cols/', 'images/layout-cols.png',
  delay=1, vwidth=1000, selector = 'section.content'
) %>%
  resize("50%") %>%
  shrink()
```

![Column-based layout](images/layout-cols.png)

The code below is the basic scaffolding for this column-based layout. Notice that within the `fluidRow`, there are `column`s with a specified width, and then each of the boxes in the column have `width=NULL`.

```{r eval=FALSE}
body <- dashboardBody(
  fluidRow(
    column(width = 4,
      box(
        title = "Box title", width = NULL, status = "primary",
        "Box content"
      ),
      box(
        title = "Title 1", width = NULL, solidHeader = TRUE, status = "primary",
        "Box content"
      ),
      box(
        width = NULL, background = "black",
        "A box with a solid black background"
      )
    ),

    column(width = 4,
      box(
        status = "warning", width = NULL,
        "Box content"
      ),
      box(
        title = "Title 3", width = NULL, solidHeader = TRUE, status = "warning",
        "Box content"
      ),
      box(
        title = "Title 5", width = NULL, background = "light-blue",
        "A box with a solid light-blue background"
      )
    ),

    column(width = 4,
      box(
        title = "Title 2", width = NULL, solidHeader = TRUE,
        "Box content"
      ),
      box(
        title = "Title 6", width = NULL, background = "maroon",
        "A box with a solid maroon background"
      )
    )
  )
)

# We'll save it in a variable `ui` so that we can preview it in the console
ui <- dashboardPage(
  dashboardHeader(title = "Column layout"),
  dashboardSidebar(),
  body
)

# Preview the UI in the console
shinyApp(ui = ui, server = function(input, output) { })
```

### Mixed row and column layout

It's also possible to use a mix of rows and columns. In this example, the top two boxes are in a row, and the rest are in columns:

```{r eval=FALSE, echo=FALSE}
appshot('_apps/layout-mixed/', 'images/layout-mixed.png',
  delay=1, vwidth=1000, selector = 'section.content'
) %>%
  resize("50%") %>%
  shrink()
```

![Mixed row and column layout](images/layout-mixed.png)

This is the scaffolding for this mixed layout:

```{r eval=FALSE}
body <- dashboardBody(
  fluidRow(
    box(
      title = "Box title", width = 6, status = "primary",
      "Box content"
    ),
    box(
      status = "warning", width = 6,
      "Box content"
    )
  ),
    
  fluidRow(
    column(width = 4,
      box(
        title = "Title 1", width = NULL, solidHeader = TRUE, status = "primary",
        "Box content"
      ),
      box(
        width = NULL, background = "black",
        "A box with a solid black background"
      )
    ),

    column(width = 4,
      box(
        title = "Title 3", width = NULL, solidHeader = TRUE, status = "warning",
        "Box content"
      ),
      box(
        title = "Title 5", width = NULL, background = "light-blue",
        "A box with a solid light-blue background"
      )
    ),

    column(width = 4,
      box(
        title = "Title 2", width = NULL, solidHeader = TRUE,
        "Box content"
      ),
      box(
        title = "Title 6", width = NULL, background = "maroon",
        "A box with a solid maroon background"
      )
    )
  )
)

# We'll save it in a variable `ui` so that we can preview it in the console
ui <- dashboardPage(
  dashboardHeader(title = "Mixed layout"),
  dashboardSidebar(),
  body
)

# Preview the UI in the console
shinyApp(ui = ui, server = function(input, output) { })
```


<div class="text-center">
**Next**: learn about customizing the appearance of a dashboard.

<a class="btn btn-success btn-lg" href="appearance.html" role="button">Continue
<span class="glyphicon glyphicon-arrow-right"></span>
</a>
</div>
