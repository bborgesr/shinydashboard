---
title: "Shiny Dashboard Mechanics"
output:
  html_document:
    toc: true
    template: ./template-toc.html
---

```{r echo = FALSE, message=FALSE}
library(shiny)
library(shinydashboard)
library(webshot)

knitr::opts_chunk$set(collapse = TRUE, comment = "##")

# Print HTML tags as HTML text
knit_print.shiny.tag <- function(x, ...) {
  as.character(x)
}
```


# **shinydashboard** mechanics and interactivity

Shinydashboard supports all the normal interactive functionality that Shiny does. If you need a refresher on all the interactive capabilities of Shiny (through inputs, outputs, reactives, etc), take a look at [our website's articles](https://shiny.rstudio.com/articles/).

## **shinydashboard**-specific components

### A caveat about `dropdownMenu`s

While it is possible to render dynamic dropdown menus, it's not possible to treat them as inputs. For exmaple, you can re-render a dynamic dropdown menu if the data changes

However, there is no current way to see if the user clicked on one of the items in a dropdown menu.

## Bookmarking


----------------

Here's where we're at right now:

- As Winston said above, it isn't currently possible to get the currently selected `notificationItem()` (or, for that matter, `messageItem()` or `taskItem()`). It might make sense to add an `id` param to the `dropdownMenu()` function and set a Shiny input with that `id`. To get this working properly (and play nice with bookmarking, document, etc.) is a reasonable amount of work, so we're not doing it for the upcoming release (May 2017). I opened another issue targeted specifically at this, with some ideas of what we'd want to do for that feature: #208 

- As Winston also said, it's already possible to find the currently-selected `menuItem()` or `menuSubItem()`, if the `sidebarMenu()` has an `id`, and the `menuItem()`/`menuSubItem()` has a `tabName`. 
  
  <details>
  <summary>Here's an example (<strong>click on the arrow to show the code</strong>).<p>Notice that no <code>tabItems( tabItem(), tabItem(), ... )</code> is used in this app, even though all childless <code>menuItem()</code>s and <code>menuSubItem()</code>s have a <code>tabName</code> argument.</p></summary>
  
  ```r
  library(shiny)
  library(shinydashboard)

  ui <- dashboardPage(
    dashboardHeader(), 
    dashboardSidebar(
      sidebarMenu(
        # Setting id makes input$tabs give the tabName of currently-selected tab
        id = "tabs",
        
        menuItem("Dashboard", tabName = "dashboard", icon = icon("dashboard")),
        menuItem("Widgets", icon = icon("th"), tabName = "widgets", badgeLabel = "new"),
        menuItem("Charts", icon = icon("bar-chart-o"),
          menuSubItem("Sub-item 1", tabName = "subitem1"),
          menuSubItem("Sub-item 2", tabName = "subitem2")
        )
      )
    ),
    dashboardBody(
      textOutput("res")
    )
  )

  server <- function(input, output, session) {
    output$res <- renderText({
      paste("You've selected:", input$tabs)
    })
  }

  shinyApp(ui, server)
  ```
  
  </details>
  <br>

  **Caveats**:
  - As mentioned, `sidebarMenu()` must take in an `id`. For example if you pass in `id = "tabs"`, then, anywhere in the server function, you can know which `menuItem()` (or `menuSubItem()`) is selected by accessing `input$tabs`.

  - Childless `menuItem()`s (and `menuSubItem()`s) v childfull `menuItem()`s behave differently and there's different arguments that apply to either:
     - Childless `menuItem()`s/`menuSubItem()`s must be given a `tabName` param; in addition, *one* of these can have `selected = TRUE`, which lets Shiny know that you want `input$tabs` to start out this that item's `tabName` on app startup (if you specified a `tabItem()` for that `tabName`, that will what you first see in the dashboard body when you launch your app).
     - "Childfull" `menuItem()`s cannot have a `tabName` or a `selected` argument (or rather, they can, but this will be completely ignored by Shiny). Instead (and once #199 is merged), at most, *one* of them can take a `startExpanded = TRUE`, which tells Shiny to start up with that `menuItem()` expanded, i.e. revealing all its children. (The reason that, at most, only one childfull `menuItem()` can start expanded is because in general in AdminLTE, only one thing can be expanded in the sidebar at any one time). In alternative to `tabName`, you can pass in an `expandedName`, which is how Shiny lets you know which (if any) `menuItem()` is currently expanded (more on that below, and note that this also required #199 to have been merged).

  - _This last one is more of a **bonus (!!)** than a caveat, but oh well..._
     Once #199 is merged, you also get a couple of other things "for free" (no need to add an `id` or anything, like above):
       - There's an automatic way to access which childfull `menuItem()` (if any) is currently expanded. Anywhere on your server function use `input$sidebarItemExpanded` to get the `expandedName` of the currently expanded `menuItem()` (or `NULL` is none is currently expanded). (Don't worry: even if you don't pass in an `expandedName`, Shiny has a sensible default -- it will construct one for you by taking the mandatory `text` argument you passed and removing all white space.) You can use `input$sidebarItemExpanded` as any other input, including making other UI elements conditional on it. And the cherry on top: since you get this input "for free," you also get bookmarking of this input "for free." (I.e. the bookmarked URL will capture which, if any, `menuItem()` was expanded and on restore, it will expand the same).

       - Similarly, there is also an automatic way to access whether the whole sidebar is expanded or collapsed at the moment. Use `input$sidebarCollapsed` to know if the sidebar is collapsed (`"true"`) or expanded (`"false"`). While this may seem less interesting than the former, it is mostly useful for bookmarking. (I.e. the bookmarked URL will capture whether the sidebar is collapsed or expanded and, on restore, it will have the same value and look).

--------

So, TLDR:

- the original ask for `menuItem()`s is already possible;
- the original ask for `notificationItem()`s (and their message and task counterparts) is sketched out in #208 for future development;
- there's a few caveats, as well as extra goodies that come in once #199 is merged.
