---
title: "Shiny Dashboard Behavior"
output:
  html_document:
    toc: true
    template: ./template-toc.html
---

```{r echo = FALSE, message=FALSE}
library(shiny)
library(shinydashboard)

knitr::opts_chunk$set(collapse = TRUE, comment = "##")

# Print HTML tags as HTML text
knit_print.shiny.tag <- function(x, ...) {
  as.character(x)
}

```

Shinydashboard supports all the normal interactive functionality that Shiny does. If you need a refresher on all the interactive capabilities of Shiny (through inputs, outputs, reactives, etc), take a look at [our website's articles](https://shiny.rstudio.com/articles/).

# shinydashboard-specific components

In addition to all the normal Shiny inputs and outputs that can be present in a shinydashboard app, there are a few things that are specific to the structure of such apps. In particular, most shinydashboard apps have a sidebar. As of the 0.6 shinydashboard release, app authors can access the entire state of the sidebar as Shiny inputs. There are up to three inputs that can be generated if you have a sidebar in your app. (However, it should be noted that two these are not "normal" inputs, since they are generated automatically and have a fixed name -- rather than you, as the app author, deciding that name.)

Let's get into the details. The three sidebar-related inputs allow you to:

## Know which **menuItem()** or **menuSubItem()** is currently selected

You can find the currently-selected `menuItem()` or `menuSubItem()`, provided that the `sidebarMenu()` has an `id` (and the `menuItem()`/`menuSubItem()` has a `tabName`). In particular, if you pass in `id = "tabs"` to your `sidebarMenu()`, then you can know which sidebar item is selected by accessing the variable `input$tabs`. The value associated with `input$tabs` is given by the `tabName` argument of the currently selected `menuItem()` (or `menuSubItem()`).
  
Here is a small example app. Notice that all childless `menuItem()`s and `menuSubItem()`s have a `tabName` argument:

<details>
  <summary>app.R</summary>
  
```{r eval=FALSE}
library(shiny)
library(shinydashboard)

ui <- dashboardPage(
  dashboardHeader(), 
  dashboardSidebar(
    sidebarMenu(
      # Setting id makes input$tabs give the tabName of currently-selected tab
      id = "tabs",
      
      menuItem("Dashboard", tabName = "dashboard", icon = icon("dashboard")),
      menuItem("Widgets", icon = icon("th"), tabName = "widgets", badgeLabel = "new"),
      menuItem("Charts", icon = icon("bar-chart-o"),
        menuSubItem("Sub-item 1", tabName = "subitem1"),
        menuSubItem("Sub-item 2", tabName = "subitem2")
      )
    ),
    textOutput("res")
  ),
  dashboardBody(
    tabItems(
      tabItem("dashboard", "Dashboard tab content"),
      tabItem("widgets", "Widgets tab content"),
      tabItem("subitem1", "Sub-item 1 tab content"),
      tabItem("subitem2", "Sub-item 2 tab content") 
    )
  )
)

server <- function(input, output, session) {
  output$res <- renderText({
    paste("You've selected:", input$tabs)
  })
}

shinyApp(ui, server)
```

</details>

### Caveats and other small print

- As mentioned, `sidebarMenu()` _must_ take in an `id`. For example if you pass in `id = "tabs"`, then, anywhere in the server function, you can know which `menuItem()` (or `menuSubItem()`) is selected by accessing `input$tabs`. If you don't pass in an `id`, you won't be able access to this information. In addition, you need to specify a `tabName` for all "leaf" items (i.e. all `menuItem()`s or `menuSubItem()`s that don't have any children), even if you wouldn't need it otherwise. If you don't specify a `tabName`, then that item will not be clickable, though the the other items will continue to function as normal (i.e. not specifying a `tabName` for an item is functionally the same as not having that item at all - except for the different visual look - since you won't be able to interact with it at all).


- This works exactly the same for dynamically generated `sidebarMenu()`s. Here's an identical looking app, whose only difference is that the sidebar menu is generated dynamically:

    <details>
      <summary>app.R</summary>
    
    ```{r eval=FALSE}
    library(shiny)
    library(shinydashboard)
    
    ui <- dashboardPage(
      dashboardHeader(), 
      dashboardSidebar(
        sidebarMenuOutput("menu")
      ),
      dashboardBody(
        textOutput("res")
      )
    )
    
    server <- function(input, output, session) {
      output$res <- renderText({
        paste("You've selected:", input$tabs)
      })
      output$menu <- renderMenu({
        sidebarMenu(
          # Setting id makes input$tabs give the tabName of currently-selected tab
          id = "tabs",
          
          menuItem("Dashboard", tabName = "dashboard", icon = icon("dashboard")),
          menuItem("Widgets", icon = icon("th"), tabName = "widgets", badgeLabel = "new"),
          menuItem("Charts", icon = icon("bar-chart-o"),
            menuSubItem("Sub-item 1", tabName = "subitem1"),
            menuSubItem("Sub-item 2", tabName = "subitem2")
          )
        )
      })
    }
    
    shinyApp(ui, server)
    ```
      
    </details>
    
    _Note_: There used to be a bug in shinydashboard that would result in no item starting as selected if the sidebar menu was rendered dynamically. This was been fixed in shinydashboard 0.6. In short, there should always be a selected item when the sidebar menu finishes rendering. This can be specified by the app author by adding the argument `selected = TRUE` to the desired `menuItem()` or `menuSubItem()`. If none is specified, the first item that has a `tabName` will be selected by default.
    

- Childless `menuItem()`s (and `menuSubItem()`s) and "childfull"" `menuItem()`s behave differently and there's different arguments that apply to either:

    - Childless `menuItem()`s/`menuSubItem()`s must be given a `tabName` argument; in addition, *one* of these can have `selected = TRUE`, which lets Shiny know that you want `input$tabs` (if you passed in `id = "tabs"` to `sidebarMenu()`) to start out with that item's `tabName` on app startup (if you specified a `tabItem()` for that `tabName`, that will what you first see in the dashboard body when you launch your app).
  
    - "Childfull" `menuItem()`s cannot have a `tabName` or a `selected` argument (or rather, they can, but this will be completely ignored by Shiny). Instead, at most, *one* of them can take a `startExpanded = TRUE`, which tells Shiny to start up with that `menuItem()` expanded, i.e. revealing all its children. (The reason that, at most, only one childfull `menuItem()` can start expanded is because in general in AdminLTE, only one thing can be expanded in the sidebar at any one time). In alternative to `tabName`, you can pass in an `expandedName`, which is how Shiny lets you know which (if any) `menuItem()` is currently expanded.

## Know which **menuItem()**, if any, is currently expanded

There's an automatic way to access which childfull `menuItem()` (if any) is currently expanded. Anywhere on your server function use `input$sidebarItemExpanded` to get the `expandedName` of the currently expanded `menuItem()` (or `NULL` is none is currently expanded). (Don't worry: even if you don't pass in an `expandedName`, Shiny has a sensible default -- it will construct one for you by taking the mandatory `text` argument you passed and removing all white space.) You can use `input$sidebarItemExpanded` as any other input, including making other UI elements conditional on it. And the cherry on top: since you get this input "for free," you also get bookmarking of this input "for free." (I.e. the bookmarked URL will capture which, if any, `menuItem()` was expanded and on restore, it will expand the same).

## Know whether the whole sidebar is expanded or collapsed

Similarly, there is also an automatic way to access whether the whole sidebar is expanded or collapsed at the moment. Use `input$sidebarCollapsed` to know if the sidebar is collapsed (`"true"`) or expanded (`"false"`). While this may seem less interesting than the former, it is mostly useful for bookmarking. (I.e. the bookmarked URL will capture whether the sidebar is collapsed or expanded and, on restore, it will have the same value and look).

# Bookmarking

These additions to shinydashboard will allow it to integrate a lot better  with [bookmarkable state](https://shiny.rstudio.com/articles/bookmarking-state.html). As of shinydashboard 0.6, the state of the sidebar will be automatically bookmarked. For example, the app below does not specify any explicit inputs, but the state of the sidebar is automatically bookmarked (you can see this in the URL):

<details>
  <summary>app.R</summary>
  
```{r eval=FALSE}
library(shiny)
library(shinydashboard)

ui <- dashboardPage(
    dashboardHeader(),
    dashboardSidebar(),
    dashboardBody()
)

server <- function(input, output, session) {   
    observe({
        # Trigger this observer every time an input changes
        reactiveValuesToList(input)
        session$doBookmark()
    })
    onBookmarked(function(url) {
        updateQueryString(url)
    })
}
enableBookmarking("url")
shinyApp(ui, server)
```

</details>
 
# A note about **dropdownMenu**s

While it is possible to render dynamic dropdown menus, it's not possible to treat them as inputs. For example, you can re-render a dynamic dropdown menu if the data changes. For instance, in this app, we can dynamically add items to a `dropdownMenu` via a modal window:

<details>
  <summary>app.R</summary>
  
```{r, eval = FALSE}
library(shiny)
library(shinydashboard)

ui <- dashboardPage(
  dashboardHeader(title = "Dropdowns 2.0",
    dropdownMenuOutput("menu")
  ),
  dashboardSidebar(
    helpText("Add another item to the dropdown menu by clicking ",
             "on the button below"),
    actionButton("addItem", "Add another item")
  ),
  dashboardBody()
)

server <- function(input, output, session) {
  tasks <-  reactiveValues(
      code = list(id = "code", value = 15, color = "aqua",
                  text = "Refactor code"),
      layout = list(id = "layout", value = 40, color = "green",
                    text = "Design new layout"),
      docs = list(id = "docs", value = 25, color = "red",
                  text = "Write documentation")
    )

  # actually render the dropdownMenu
  output$menu <- renderMenu({
    items <- lapply(tasks, function(el) {
      taskItem(value = el$value, color = el$color, text = el$text)
    })
    dropdownMenu(
      type = "tasks", badgeStatus = "danger",
      .list = items
    )
  })

  observeEvent(input$addItem, {
    showModal(modalDialog(title = "Add new task",
      textInput(paste0("id", input$addItem), "Task ID"),
      numericInput(paste0("val", input$addItem), "Task value", 0),
      selectInput(paste0("col", input$addItem), "Task color",
        choices = c("red", "yellow", "aqua", "blue",
          "light-blue", "green", "navy", "teal",
          "olive", "lime", "orange", "fuchsia",
          "purple", "maroon", "black")
      ),
      textInput(paste0("text", input$addItem), "Task text"),
      actionButton(paste0("go", input$addItem), "Add item"),
      easyClose = TRUE, footer = NULL
    ))

    observeEvent(input[[paste0("go", input$addItem)]], {
      tasks[[paste0("id", input$addItem)]] <- list(
        id = input[[paste0("id", input$addItem)]],
        value = input[[paste0("val", input$addItem)]],
        color = input[[paste0("col", input$addItem)]],
        text = input[[paste0("text", input$addItem)]]
      )
      removeModal()
    })
  })
}

shinyApp(ui, server)
```

</details>

However, there is no current way to see if the user clicked on one of the items in a dropdown menu. This is something that is not originally supported in [AdminLTE](https://almsaeedstudio.com/preview). While we may add this functionality in the future, for now, we can only keep track of things that have a Shiny input binding. (To be more specific, if you write your own custom Javascript, you can get around this limitation, but it's not always trivial and it's not natively supported by shinydashboard.)
